> 🔴pytest 允许使用标准的python assert 用于验证Python测试中的期望和值。所以并不像unittest的那么丰富。但是我们可以重写。

### 小例子--介绍
```python
import pytest

class Testnew:
    def test_num(self):
        assert 1 == "1"

    def test_dic(self):
        assert {"QA":"清安"} == {'QA':"拾贰"}

    def test_list(self):
        assert [1,2,3] == [1,2,3]
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/25452484/1670905243616-1c038b5e-3a86-4959-bfcf-5385f5d9e1d5.png#clientId=u7d387657-076f-4&from=paste&height=97&id=ue6b66203&name=image.png&originHeight=121&originWidth=1035&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20526&status=done&style=none&taskId=u6caae7e4-665a-449a-ab83-c25687d9928&title=&width=828)
### 断言失败提示
```python
class Test_a:
    def test_a1(self):
        assert 1 > 2, "1不大于2"
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/25452484/1670923963664-2b0061c9-fdf9-4725-bc43-0c1c9f1f38d4.png#clientId=u050b72c7-c667-4&from=paste&height=190&id=ubc33be9e&name=image.png&originHeight=237&originWidth=1168&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18988&status=done&style=none&taskId=ufac10a99-ba1c-4174-be71-f935dad90e4&title=&width=934.4)
### 模拟示例
```python
def func(first,last):
    dic = {"url":first,"code":last}
    if dic["url"] == 'https://blog.csdn.net/weixin_52040868':
        return dic["code"]
    else:
        return '404'
f = func('https://blog.csdn.net/weixin_52040868','200')

class Testnew:

    def test_dic(self):
        if isinstance(f,dict):
            assert f['code'] == '200'
```
举了一个简单的示例，意思就是如果url准确，则返回200的返回值对应请求成功的意思。并在pytest的测试用例中进行断言(这只是一个有限的断言示例)。
# 预期异常断言
为了编写有关引发的异常的断言，可以使用 pytest.raises() 作为这样的上下文管理器
```python
import pytest

def test_zero():
    with pytest.raises(ZeroDivisionError):
        print(1/0)
```
> 正常情况下1/0是不允许的，也就是程序会抛出异常，那么此处呢：
> ![image.png](https://cdn.nlark.com/yuque/0/2022/png/25452484/1670915782435-0d4eba7f-c7e4-448f-b311-2b9cc9408f60.png#clientId=u050b72c7-c667-4&from=paste&height=178&id=udd613a38&name=image.png&originHeight=222&originWidth=798&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21348&status=done&style=none&taskId=uea4b4860-3283-4d20-96cd-9fdc597ba1d&title=&width=638.4)
> 很意外的标志为PASS了。为什么？

> pytest.raises作为上下文管理器，它将捕获给定类型的异常，也就是说，1/0已经触发了ZeroDivisionError的异常了，程序在运行的过程中已经将其捕捉。那么我们如何获取捕捉到的信息呢？

```python
import pytest

def test_zero():
    with pytest.raises(ZeroDivisionError) as ecpt:
        print(1/0)
    print(ecpt.value)
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/25452484/1670916202764-47b4a653-977e-49b9-8e27-6fcdc2aa014a.png#clientId=u050b72c7-c667-4&from=paste&height=243&id=u9c777dc6&name=image.png&originHeight=304&originWidth=1030&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32798&status=done&style=none&taskId=u5825e456-713f-4015-b910-1e3c2da14ce&title=&width=824)
> 💥看到了吗，division by zero。此外我们还可以做一些别的改变，如下：

```python
def func():
    raise ValueError("Exception QINGAN raised!!")

def test_value():
    with pytest.raises(ValueError,match=r".*QINGAN.*") as ecpt:
        func()
    print(ecpt.value)
    print(ecpt.value.args[0])
```
> 我们主动抛出异常，然后在测试用例中使用match参数做正则截取判断，如果没有则会抛出异常，如果有，则pass掉。此外我们可以使用value.args[0]，单独拿到抛出的异常值:"Exception QINGAN raised!!"

# 自定义断言信息
首先需要在同级目录下创建一个conftest.py文件名不允许更改，只能是这个名称，后续会讲到。
```python
from pythonpp.pytest_.test_b import Foo

def pytest_assertrepr_compare(op, left, right):
    if isinstance(left, Foo) and isinstance(right, Foo) and op == "==":
        return [
            "Comparing Foo instances:",
            "   vals: {} != {}".format(left.val, right.val),
        ]
```
conftest.py中的函数方法名也不允许更改，另一个test用例文件命名随意符合规则即可，这里是test_b.py:
```python
class Foo:
    def __init__(self, val):
        self.val = val

    def __eq__(self, other):
        return self.val == other.val

def test_compare():
    f1 = Foo(1)
    f2 = Foo(2)
    assert 1 == 2
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/25452484/1670920429490-eb81e8d9-86c1-42ff-b687-a4ca13956c29.png#clientId=u050b72c7-c667-4&from=paste&height=377&id=ud2b741d4&name=image.png&originHeight=471&originWidth=1194&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47648&status=done&style=none&taskId=uc46469d8-958b-48c3-b447-ac8cece8809&title=&width=955.2)
> conftest.py内容看不明白，说明基础还是太差，那么我直接简易化掉：

```python
def pytest_assertrepr_compare(op, left, right):
    if left and right and op == "==":
        return [
            "==断言错误:",
            "{} != {}".format(left,right)
        ]
```
```python
def test_compare():
    assert 1 == 2
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/25452484/1670920816801-10133d14-76e2-4cfb-9956-c35e9fc8358e.png#clientId=u050b72c7-c667-4&from=paste&height=438&id=u82e1b886&name=image.png&originHeight=548&originWidth=1125&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52455&status=done&style=none&taskId=u7c4a8e28-c5ca-4d15-96a5-56fd2862723&title=&width=900)
> 🔴注意，这里只是重写了==的断言逻辑，对于其他的不适用，需要重写。

# 小结
还有部分是不常用的，此处就不介绍了，例如预期警告断言 warnings  。

